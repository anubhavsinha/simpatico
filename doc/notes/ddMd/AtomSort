What to sort, and when

  -------------------------------------------------------------

  Proposal 1) Sort all local and ghost atoms, after they all
  exist. 

  When: This could be done immediately after exchange. 

  Pro: Comparatively simple to program, separate from exchange.

  Con: The sorting of ghost atoms is pointless, since new
  memory addresses will be chosen during the next exchange.

  -------------------------------------------------------------
  Proposal 2) Only sort local atoms.

  When: This would have to be done after private exchangeAtoms
  and before exchangeGhosts.

  Pro: Avoid pointless sorting of ghost atoms.

  Con: Requires careful integration with exchange operation.
  The communication plans calculated during exchangeAtoms would
  remain valid, and could be copied to new locations. The 
  pointers to local atoms added to the sendArray would, however,
  be invalidated by the sort. This is the main problem.

  Solution: Add bool "sort" parameter to exchangeAtoms and
  exchangeGhosts. If bool is true, don't add atoms to the send 
  list in exchangeAtoms, and do add them in exchangeGhosts.

------------------------------------------------------------
Algorithm (for either proposal, with slight differences)

   - Proposed functions for AtomArray:

        void addGroupExchanger(GroupExchanger& exchanger);

        void AtomArray::sort(Array<Atom*>& sequence, 
                             AtomStorage& atomStorage);

        The sequence would be an array of pointers to local atoms
        in the desired order.

   - Copy all local atom data to new arrays, from bottom. 

   - If we are sorting ghosts: Copy all ghost atom data to new 
     arrays, from top. Since the sequence is less important, this 
     can use the list of ghost atoms from the AtomStorage, and 
     fill the new array starting from the top.

   - Swap array addresses.

   - Clear all local (and possibly ghost atoms) from the AtomStorage.
     Add clearAll(AtomArray& method) ?

   - Add new local addresses to AtomStorage, adding sequentially 
     from the bottom of the AtomArray.

   - If we are sorting ghotss, add new ghost addresses to AtomStorage, 
     adding sequentially from the top.

   - For each registered GroupExchanger, reset all Atom* pointers 
     in groups.

---------------------------------------------------------------------
Proposal: 

     Change the AtomStorage reservoir from a stack to a double ended 
     queue. 

     Create a container ArrayDQueue for use as a reservoir.
