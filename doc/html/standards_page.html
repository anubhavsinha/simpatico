<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simpatico: 7.2 Coding Standards</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simpatico
   &#160;<span id="projectnumber">v1.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">Simpatico - Simulation Package for Polymer and Molecular Liquids</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">7.2 Coding Standards </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This file documents programming and formatting conventions that should be used in the source code of Simpatico:</p>
<h2><a class="anchor" id="file_section"></a>
File Conventions</h2>
<ul>
<li>Header files name use file extension .h and source (implementation) files use .cpp.</li>
</ul>
<ul>
<li>Write one public class per file. The base name of the header and implementation files should be the class name: The header and source files for class MyClass should be MyClass.h and MyClass.cpp.</li>
</ul>
<ul>
<li>Use header guards in all header files.</li>
</ul>
<h2><a class="anchor" id="name_section"></a>
Name Conventions</h2>
<ul>
<li>Names of functions and variables are lower case camel, as in "myVariable" or "myData".</li>
</ul>
<ul>
<li>Names of user-defined types (class, typedef, and enum) and namespaces are upper case camel, as in "MyClass" or "Util".</li>
</ul>
<ul>
<li>Names of class member variable names (other than static constants) end with a trailing underscore, like "data_" or "outputFile_". Such variables are all private or (occasionally) protected.</li>
</ul>
<ul>
<li>Static constant class member variable names are upper case camel, as in "MaxDimension". These may be public.</li>
</ul>
<ul>
<li>Use plural knowns for names of arrays and other containers. An array of Atom objects might thus be named "atoms", or "atoms_" if it is a class member.</li>
</ul>
<ul>
<li>Names of pointer variables end with a suffix Ptr. A local Atom* pointer variable within a function might thus be called "atomPtr", while an Atom* class member might be called "atomPtr_". Do not use this convention for pointers that point at C arrays (and prefer containers to bare C-arrays).</li>
</ul>
<ul>
<li>Names of preprocessor macros are upper case, with underscores between words. No preprocessor macros other than include guards should be defined in header files, or in files that contain class templates.</li>
</ul>
<ul>
<li>Use the same parameter names in function definitions and corresponding declarations.</li>
</ul>
<ul>
<li>Names of functions that are not simple accessors (discussed below) should generally be verbs.</li>
</ul>
<ul>
<li>The name of a "setter" function that is passed a value for a member should begin with the prefix "set". The name of a parameter that holds a new value in such a function should be the same as the name of the member variable, without the trailing underscore. The same convention is used whether the value is passed by value or by reference. For example: <div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> Thing::setData(<span class="keywordtype">int</span> data)
    {  data_ = data; }

    <span class="keywordtype">void</span> Thing::setPosition(<span class="keyword">const</span> Vector &amp;position)
    {  position_ = position; }

    <span class="keywordtype">void</span> Thing::setMolecule(Molecule &amp;molecule)
    {  moleculePtr_ = &amp;molecule; }
</pre></div></li>
</ul>
<ul>
<li>The name of simple accessor ("getter") functions that return a member variable by value or by reference should be the name of the member variable, without the trailing underscore. Simpatico does NOT use the convention of appending a prefix "get" to the name of simple accessors. The same syntax is use for accessors that return by value, const reference, or non-const reference. Thus, for example: <div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> Thing::data()<span class="keyword"> const</span>
<span class="keyword">    </span>{  <span class="keywordflow">return</span> data_; }

    <span class="keyword">const</span> Vector&amp; Thing::position()<span class="keyword"> const</span>
<span class="keyword">    </span>{  <span class="keywordflow">return</span> position_; }

    Vector&amp; Thing::position()
    {  <span class="keywordflow">return</span> position_; }

    Molecule&amp; Thing::molecule()
    {  <span class="keywordflow">return</span> *moleculePtr_; }
</pre></div></li>
</ul>
<ul>
<li>The name of the preprocessor macro used in a header guard should be the name of the namespace followed by the file name, in upper case with underscores between words. A header a file named "SillyClass.h" that contains a class Util::SillyClass in namespace <a class="el" href="namespaceUtil.html" title="Utility classes for scientific computation.">Util</a> should be enclosed with header guards like this: <div class="fragment"><pre class="fragment"><span class="preprocessor">#ifndef UTIL_SILLY_CLASS_H</span>
<span class="preprocessor"></span><span class="preprocessor">#define UTIL_SILLY_CLASS_H</span>
<span class="preprocessor"></span>
<span class="keyword">namespace </span>Util
{

   <span class="keyword">class </span>SillyClass : derived Base
   {
      \\ ....
   } 

}
<span class="preprocessor">#endif</span>
</pre></div></li>
</ul>
<h2><a class="anchor" id="format_section"></a>
Code Formatting:</h2>
<ul>
<li>Indent exactly 3 spaces per level. Do NOT use any tabs.</li>
</ul>
<ul>
<li>For control structures (if, for, while, etc.), place the opening brace at the end of a line, and the closing brace on a line by itself, aligned with the beginning of the opening line, like this: <div class="fragment"><pre class="fragment">   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; end; ++i) {
      doSomething();
   }
</pre></div></li>
</ul>
<ul>
<li>For functions with more than one line, put the opening brace on a separate line, and align opening and closing braces, like this: <div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> SillyClass::sillyMethod(<span class="keywordtype">int</span> param1, <span class="keywordtype">int</span> max)
   {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; max; ++i) {
         param1++;
      }
   
      <span class="keywordflow">if</span> (param1 &gt; 0) {
         <span class="keywordflow">return</span> 0;
      } <span class="keywordflow">else</span> {
         <span class="keywordflow">return</span> 1;
      }
   }
</pre></div></li>
</ul>
<ul>
<li>For one-line functions, the function definition may be given on a single line, like this: <div class="fragment"><pre class="fragment">   <span class="keyword">inline</span> <span class="keywordtype">int</span> SillyClass::data() 
   {  <span class="keywordflow">return</span> data_; }
</pre></div></li>
</ul>
<ul>
<li>Set off the operators =, ==, &lt;, &gt;, +, and - by one space on either side. Multipication (*) and division (/) operators may or may not be set off by white space. Make occasional exceptions to avoid line wraps.</li>
</ul>
<ul>
<li>Use one space to separate keywords, parentheseses, and opening braces in conditional statements. Use one space after each semi-colon in for-loop statements, and one space after each comma in function parameter lists.</li>
</ul>
<ul>
<li>Do not follow opening parentheses or precede closing parentheses by a space. Do not add whitespace space before commas or semicolons.</li>
</ul>
<ul>
<li>Break lines at 80 characters or less whenever possible, to preserve readability in printouts.</li>
</ul>
<ul>
<li>Wrap every source file in the src/ directory in a namespace block. Start the namespace declaration in the first column.</li>
</ul>
<ul>
<li>Consecutive function declarations or definitions within a file, along with associated documentation blocks, should be separated by a single blank line.</li>
</ul>
<ul>
<li>In class definitions, align "public:", "protected:", and "private:" declarations with the beginning of the class definition statement, and with the closing brace. List public members first, then protected, then private. Within each block, list data members first, then methods.</li>
</ul>
<ul>
<li>List any friend declarations at the end of a class definition in a "pseudo-block" that is preceded by a comment "//friends:" on a line by itself, after the private members. The "//friends:" comment should be aligned with "public:" and "private:" declarations.</li>
</ul>
<ul>
<li>Inline method definitions should be given outside the class definition, within the header file. The word "inline" should be added to the function definition, but not the function declaration.</li>
</ul>
<ul>
<li>Example (with doxygen documentation): <div class="fragment"><pre class="fragment">
#ifndef UTIL_SILLY_CLASS_H
#define UTIL_SILLY_CLASS_H

namespace Util
{

   /*\*
   * A truly pointless class.
   */
   class SillyClass : public Base
   {
   
   public:
 
      /**
      * The first method.
      *
      * \param param1 a globble
      * \param param2 a gloob 
      */ 
      int method1(int param1, double param2);

      /**
      * Get buddy (by reference)
      */
      const Buddy&amp; buddy() const;

   protected:

      /**
      * Get buddy  by non const reference)
      */
      Buddy&amp; buddy();

   private:
   
      int      data1_;
      Buddy* buddyPtr_;
   
   //friends:
   
      friend class Buddy;
   
   };

   // Inline methods

   inline const Buddy&amp; SillyClass::buddy() const 
   {  return *buddyPtr_; }

   inline Buddy&amp; SillyClass::buddy() 
   {  return *buddyPtr_; }

}
#endif
</pre></div></li>
</ul>
<h2><a class="anchor" id="Dox_section"></a>
Documentation Conventions (via doxygen):</h2>
<p>Simpatico uses the doxygen (www.doxygen.org) utility to create html documentation from documentations blocks that are extracted from the source code. Doxygen will extracts any multi-line comment that begin with a slash and two asterisks ("/**"), or single line comments that begin with three slashes ("///"), like this: </p>
<div class="fragment"><pre class="fragment">

   /** 
   * This is a doxygen documentation block.
   */

   /// and So is this. 

   /*
   * but this will not be extracted,
   */

   // nor will this

</pre></div><p> Comments that should not be extracted by doxygen should use the usual form for multi-line comments, using only a single asterisk, or for single line comments, using only two slashes. The documentation block for a class or function should appear immediately above the first line of the class definition or function declaration.</p>
<ul>
<li>Create dOxygen documentation blocks for public and protected named quantities, i.e., all classes, public and protected member functions, protected member variables, namespaces, global functions, typedefs, enums, and constants.</li>
</ul>
<ul>
<li>Place the doxygen documentation block for functions above the function declaration (within the header file), rather than above the function definition (which may be in a separate source file). More detailed discussion may be given on subsequent lines if needed.</li>
</ul>
<ul>
<li>Document all parameters of public and protected functions, using the dOxygen param keyword.</li>
</ul>
<ul>
<li>The documentation for every class and public or protected function should begin with a brief single-sentence synopsis, which must end with a period and be followed by a blank line. This brief description is often sufficient. More detailed discussion may be given on subsequent lines, if needed. Example: <div class="fragment"><pre class="fragment">

   /**
   * Align the universe. 
   *
   * This is a longer discussion of what the method does, and of how and
   * why it does it. It may also contain a discussion of assumptions, and
   * of the algorithm. 
   *
   * A longer discussion may contain two or more paragraphs, separated by
   * blank lines.
   *
   * \param thing1 value of some quantity
   * \param thing2 flag to determine what to do with thing1
   * \return shift in the position of the universe
   */
   double alignUniverse(double thing1, bool thing2);

</pre></div></li>
</ul>
<ul>
<li>Private class member variables may be documented either using the multi-line or single line doxygen format.</li>
</ul>
<ul>
<li>Use a conventional C/C++ comment format that will not be extracted by doxygen (with one asterisk, or two slashes) above the definition of a class member function outside of the class definition, like this: <div class="fragment"><pre class="fragment">   <span class="comment">/* </span>
<span class="comment"> Brief reminder of purpose. Possibly comments on implementation.</span>
<span class="comment">   */</span>
   <span class="keywordtype">void</span> MyClass:myFunction(<span class="keywordtype">int</span> param)
   {
       <span class="comment">// Do something here</span>
   }
</pre></div></li>
</ul>
<h2><a class="anchor" id="interface_section"></a>
Design Guidelines</h2>
<ul>
<li>All nonstatic class member variables should be private or (occassionally) protected.</li>
</ul>
<ul>
<li>Pass and return primitive C/C++ data types by value. Pass such values by non-const reference when they must be modified within a function.</li>
</ul>
<ul>
<li>Pass objects (class instances) to functions by reference, not by value. Pass by const reference whenever possible.</li>
</ul>
<ul>
<li>Prefer references over pointers as method parameters. Pass pointers to functions only if: i) a null value for the pointer is a meaningful possibility, or ii) the pointer contains an address that must be re-assigned within the function.</li>
</ul>
<ul>
<li>Prefer references over pointers as function return values. Return pointers only if a null pointer is a meaningful possibility.</li>
</ul>
<ul>
<li>Practice strict "const correctness". Mark function parameters and class member functions as const whenever possible.</li>
</ul>
<ul>
<li>Read-only access to a member variable of primitive type should be provided (when needed) by an accessor function that returns the member variable by value. Access to a class instance that is owned by a class may be provided by a accessor method that returns the object by const reference (for read-only access) or a non-const reference (for read write access). Simple accessors that return by value or const references should be marked const. For example, if a class has an int member variable data_ and a member object_ that is an instance of class Object, you might consider providing any or (none) of the following methods: <div class="fragment"><pre class="fragment">   <span class="comment">// Read access to a member of a primitive data type.</span>
   <span class="keywordtype">int</span> Thing::data()<span class="keyword"> const</span>
<span class="keyword">   </span>{  <span class="keywordflow">return</span> data_; }

   <span class="comment">// Read access to a member object.</span>
   <span class="keyword">const</span> Object&amp; Thing::object()<span class="keyword"> const</span>
<span class="keyword">   </span>{  <span class="keywordflow">return</span> object_; }

   <span class="comment">// Read-write access to a member object.</span>
   Object&amp; Thing::&amp;object_()
   {  <span class="keywordflow">return</span> object_; }
</pre></div></li>
</ul>
<ul>
<li>Providing an accessor function that returns a non-const reference to a member object is equivalent to making the member public, and should be used when this is what is desired, rather than actually making the member public. For example, the Atom and McSimulation classes provide the following methods: <div class="fragment"><pre class="fragment">   McSystem&amp; McSimulation::system() 
   {  <span class="keywordflow">return</span> system_; }

   Vector&amp; Atom::position() 
   {  <span class="keywordflow">return</span> system_; }
</pre></div> The advantages of this scheme are: <ul>
<li>
Uniform interface: All members must be accessed through accessors, so users need not remember which members are public and which must accessed through accessors.  </li>
<li>
Uniform name conventions: We can use a naming scheme in which all member variable names end with an underscore, without exposing underscored names outside the class implementation.  </li>
<li>
The same syntax is used for accessor functions that return by value, const reference, or reference, but the compiler will enforce access control.  </li>
<li>
Implementation hiding: The same syntax is used to access objects that are actually members of a class and those that are accessed through a pointer member. Use of accessor functions also makes it possible to add (removable) sanity checks for debugging, such as checks that pointers are not null. </li>
</ul>
</li>
</ul>
<ul>
<li>Write access to a class instance may sometimes instead be provided by an explicit "set" function. The use of a set function is preferable when one needs to check preconditions or carry out operations necessary to guarantee data validity.</li>
</ul>
<h2><a class="anchor" id="data_section"></a>
Data Structure Conventions:</h2>
<ul>
<li>Use the C++ iostream classes for all file IO. For consistency, avoid the C fscan() and fprint() methods. Use the wrapper classes in the src/format directory to simplify coding of formatted output to ostreams.</li>
</ul>
<ul>
<li>Use std::string to represent character strings whenever possible.</li>
</ul>
<ul>
<li>Use <a class="el" href="classUtil_1_1Vector.html" title="A Vector is a Cartesian vector.">Util::Vector</a> objects to represent Cartesian positions and separations, or any array of floating point numbers for which the number of elements equals the dimensionality of space (e.g., the dimensions of the Boundary for a periodic orthorhombic unit cell). Use IntVector to represent corresponding arrays of integers.</li>
</ul>
<ul>
<li>Prefer the container templates in src/util/containers over bare C arrays and STL containers. STL containers should be used when their is a need for their resizability or for other features not provided by the custom containers. Rational: The preference for the custom containers is based on the fact that:</li>
</ul>
<ul>
<li>They provide bound checking when NDEBUG is not defined, and</li>
<li>They cannot be silently resized. The second property is important for algorithms that use pointers to array elements, which could be invalidated if the array is resized.</li>
</ul>
<h2><a class="anchor" id="iterator_section"></a>
Iterator conventions:</h2>
<p>The code uses several types of container iterators, all of which follow the conventions described below. These conventions are slightly different from those of the C++ STL:</p>
<ul>
<li>All iterators overload *, -&gt;, and (prefix) ++ operators. Iterator-&gt;member returns a member of that object, and ++Iterator increments the iterator.</li>
</ul>
<ul>
<li>Every iterator provides a bool method notEnd(), which should be used as the condition to terminate a loop. This returns false when the end of the container has already been passed by the previous increment operation.</li>
</ul>
<ul>
<li>Each container provides a method begin(Iterator&amp; ) that takes the relevant type of iterator as an argument, and that initializes the iterator to the first element in the container. The standard form of a for-loop is thus:</li>
</ul>
<p>Example: </p>
<div class="fragment"><pre class="fragment">   Iterator iter;
   <span class="keywordflow">for</span> (container.begin(iter); iter.notEnd(); ++i){
      <span class="comment">// Do something with iter.</span>
   }
</pre></div><ul>
<li>Typenames for some of most important iterators are defined by typedefs. The typedef <a class="el" href="classMcMd_1_1System.html#aeee4a70e1f9b8194c170a48c8fa08826" title="Iterator for a MoleculeSet.">McMd::System::MoleculeIterator</a> is the type of iterator for all molecules of a specific Species within one System. The typedef <a class="el" href="classMcMd_1_1Molecule.html#aa586d0226ef16a1ecce1d5e7b7630ee7" title="Iterator for Atoms within a Molecule.">McMd::Molecule::AtomIterator</a> is the type for an iterator for all atoms within one molecule. The <a class="el" href="classMcMd_1_1System.html" title="A set of interacting Molecules enclosed by a Boundary.">McMd::System</a> class provides a method void begin(speciesId, iter) that initializes a System::MolecularIerator iterator iter for species number speciesId. The Molecule class provides a method void begin(iter) initializes a Molecule::AtomIterator. The syntax for a loop over all atoms in a System is thus:</li>
</ul>
<div class="fragment"><pre class="fragment">   System system;
   System::MoleculeIterator molIter:
   Molecule::AtomIterator   atomIter:

   <span class="comment">// Loop over species</span>
   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSpecies = 0; iSpecies &lt; nSpecies; ++iSpecies) {

      <span class="comment">// Loop over molecules in species</span>
      <span class="keywordflow">for</span> (system.begin(species, molIter); !molIter.atEnd(); ++i){

         <span class="comment">// Loop over atoms in one molecule</span>
         <span class="keywordflow">for</span> (molItr-&gt;begin(species, atomIter); !atomIter.atEnd(); ++atomIter){

            <span class="comment">// Do something with atomIter</span>

         }

      }

   }
</pre></div><h2><a class="anchor" id="header_section"></a>
Header File Includes</h2>
<ul>
<li>In header files, use forward class declarations rather than including class headers when possible. Header files must be included for base classes, member objects, typdefs, templates, and base classes used in inline functions. Forward declarations may be used for types used only in function prototypes or to define types of pointer member variables.</li>
</ul>
<ul>
<li>With few exceptions, header files that are required by a source file should be included explicitly, to document the dependency, even if they would be indirectly included via another included header file. Reliance on indirect inclusion is fragile. Exceptions are:</li>
</ul>
<ul>
<li>
A class MyClass.cpp implementation file may indirectly include any header files that are included by the corresponding header MyClass.h  </li>
<li>
A derived class may indirectly include files from its base class  </li>
<li>
The <a class="el" href="Exception_8h_source.html">Exception.h</a> header is always included indirectly by including the <a class="el" href="global_8h.html" title="File containing preprocessor macros for error handling.">src/util/global.h</a> file.  </li>
</ul>
<ul>
<li>Avoid "using" statements in header files. Specifically, do not EVER use a "using std" statement to load the entire C++ standard library into a header file.</li>
</ul>
<ul>
<li>Use explicitly qualified names, such as std::cin and std:: string, in function parameter lists, within both declarations and definitions. Do this even in *.cpp implementation files, because dOxygen gets confused if you use different conventions in the declaration and the definition of a function</li>
</ul>
<h2><a class="anchor" id="error_section"></a>
Error Handling and Debugging</h2>
<ul>
<li>Include the file &lt;<a class="el" href="global_8h.html" title="File containing preprocessor macros for error handling.">util/global.h</a>&gt; in all files that use C assert() statements or that can throw exceptions. This causes NDEBUG to be defined if UTIL_DEBUG is defined, automatically includes the "Exception.h" and "Log.h" header files, and defines the UTIL_THROW(..) macro that is used to throw exceptions.</li>
</ul>
<ul>
<li>For checks that are intended only for debugging, use c assert() statements or enclose the test in a #ifndef UTIL_DEBUG .... #endif block. Undefining the UTIL_DEBUG macro, which also causes NDEBUG to be defined, will then turn off all such debugging tests.</li>
</ul>
<ul>
<li>In both debugging and release code, throw Exception objects for all errors except those caught by C assert() statements. Use the UTIL_THROW macro defined in <a class="el" href="global_8h.html" title="File containing preprocessor macros for error handling.">src/util/global.h</a> to throw Exceptions. This macro prints a message and the file and line number from which an Exception is thrown to aid debugging.</li>
</ul>
<ul>
<li>Use user-defined Exceptions only for real errors, and not for control flow. Exceptions should cause the program to terminate.</li>
</ul>
<p>Navigation:</p>
<ul style="list-style: none;">
<li>
<a class="el" href="make_page.html">7.1 Build System</a> (Previous)  </li>
<li>
<a class="el" href="developer_page.html">7 Developer Information</a> (Up)  </li>
<li>
<a class="el" href="read_param_page.html">7.3 readParam() Methods</a> (Next)  </li>
</ul>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 1 2012 17:02:48 for Simpatico by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
