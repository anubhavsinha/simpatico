<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Simpatico: Modules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simpatico&#160;<span id="projectnumber">v1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">Simpatico - Simulation Package for Polymer and Molecular Liquids</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Modules </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>A module is a class that encapsulates several Factory classes for a set of classes that were designed for a specific application area. The classes <a class="el" href="classMcMd_1_1McModule.html" title="Abstract Module for an McSimulation.">McModule</a> and <a class="el" href="classMcMd_1_1MdModule.html" title="A Module for an MdSimulation.">MdModule</a> are abstract base classes for modules designed for use with with MC and MD simulations, respectively. The developer of a new set of subclasses of, e.g., <a class="el" href="classMcMd_1_1Diagnostic.html" title="Abstract base for periodic output and/or analysis actions.">Diagnostic</a>, <a class="el" href="classMcMd_1_1Species.html" title="A Species represents a set of chemically similar molecules.">Species</a>, and <a class="el" href="classMcMd_1_1McMove.html" title="McMove is an abstract base class for Monte Carlo moves.">McMove</a> or <a class="el" href="classMcMd_1_1MdIntegrator.html" title="Abstract base for molecular dynamics integrators.">MdIntegrator</a>, can create a subclass of <a class="el" href="classMcMd_1_1McModule.html" title="Abstract Module for an McSimulation.">McModule</a> and/or <a class="el" href="classMcMd_1_1MdModule.html" title="A Module for an MdSimulation.">MdModule</a> to organize these classes. Once the developer creates a module, user of Simpatico can use an instance of the module class to add this entire set of classes to a simulation with one function call.</p>
<p>The <a class="el" href="classMcMd_1_1McModule.html" title="Abstract Module for an McSimulation.">McModule</a> class is defined as follows: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>McModule {
<span class="keyword">public</span>:

   <a class="code" href="classMcMd_1_1McModule.html#a3fb37fd0c7b548a9e6c9bb73896a008f" title="Constructor.">McModule</a>(McSimulation&amp; <a class="code" href="classMcMd_1_1McModule.html#a7e8223c7c9c918e7e587cd9e9a7c7a9a" title="Return McSimulation by reference.">simulation</a>);

   <a class="code" href="classMcMd_1_1McModule.html#a6cd7ba14b94b5e72e355ea8d3f1a23cd" title="Destructor.">~McModule</a>();

   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMcMd_1_1McModule.html#ae03d13b426df81f689966bc9cb831b85" title="Adds all factories of all types to the simulation.">addFactories</a>() = 0;

<span class="keyword">protected</span>:

   McSimulation&amp; <a class="code" href="classMcMd_1_1McModule.html#a7e8223c7c9c918e7e587cd9e9a7c7a9a" title="Return McSimulation by reference.">simulation</a>();
   McSystem&amp;     <a class="code" href="classMcMd_1_1McModule.html#ace45568b57b318530e8d5fc54c9a2c66" title="Return McSystem by reference.">system</a>();

}
</pre></div><p> In each subclass of <a class="el" href="classMcMd_1_1McModule.html" title="Abstract Module for an McSimulation.">McModule</a>, the implementation of the pure virtual addFactories() method must add a set of factories to the simulation, using the methods of the parent <a class="el" href="classMcMd_1_1McSimulation.html" title="A Monte-Carlo simulation of one McSystem.">McSimulation</a> and system objects. Normally, instances of the new factory factory classes are created in the constructor of the <a class="el" href="classMcMd_1_1McModule.html" title="Abstract Module for an McSimulation.">McModule</a> subclass, and destroyed in its destructor. The protected methods simulation() and system() return references to the parent <a class="el" href="classMcMd_1_1McSimulation.html" title="A Monte-Carlo simulation of one McSystem.">McSimulation</a> and <a class="el" href="classMcMd_1_1McSystem.html" title="A System for use in a Markov chain Monte Carlo simulation.">McSystem</a>, for use in the implementation of addFactories() by subclasses.</p>
<p>The class definition for an <a class="el" href="classMcMd_1_1MdSimulation.html" title="A molecular dynamics simulation of a single MdSystem.">MdSimulation</a> is almost identical, except for the replacement of <a class="el" href="classMcMd_1_1McSimulation.html" title="A Monte-Carlo simulation of one McSystem.">McSimulation</a> and <a class="el" href="classMcMd_1_1McSystem.html" title="A System for use in a Markov chain Monte Carlo simulation.">McSystem</a> typenames by <a class="el" href="classMcMd_1_1MdSimulation.html" title="A molecular dynamics simulation of a single MdSystem.">MdSimulation</a> and <a class="el" href="classMcMd_1_1MdSystem.html" title="A System for Molecular Dynamics simulation.">MdSystem</a> throughout.</p>
<p>The following example is used in what follows: Imagine that a user/developer writes a set of <a class="el" href="classMcMd_1_1Species.html" title="A Species represents a set of chemically similar molecules.">Species</a> and <a class="el" href="classMcMd_1_1McMove.html" title="McMove is an abstract base class for Monte Carlo moves.">McMove</a> classes that allow efficient MC simulation of star polymers. Imagine, further, that he or she defines Factory classes named StarSpeciesFactory and StarMcMoveFactory, and packages them in a subclass of <a class="el" href="classMcMd_1_1McModule.html" title="Abstract Module for an McSimulation.">McModule</a> named StarMcModule.</p>
<h2><a class="anchor" id="module_use_sec"></a>
Using a Module (public interface)</h2>
<p>Here is an example of a simple main MC program that uses an an instance of the StarmcModule class discussed above. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>McMd
{

   <span class="keywordtype">int</span> main 
   {
      McSimulation  sim;
      StarMcModule    module(sim);

      module.addFactories();

      sim.readParam();
  
      sim.readCommands();
  
   }

}
</pre></div><p> In this example, the constructor for the StarMcModule must create an instance of StarSpeciesFactory and StarMcMove Factory, which are then added to the simulation by the addFactories() method.</p>
<p>The addFactories() method of a module must be called in the main program before the readParam() method of the main <a class="el" href="classMcMd_1_1McSimulation.html" title="A Monte-Carlo simulation of one McSystem.">McSimulation</a> or <a class="el" href="classMcMd_1_1MdSimulation.html" title="A molecular dynamics simulation of a single MdSystem.">MdSimulation</a> object, because the custom factories created by the module are used to help parse the parameter file.</p>
<h2><a class="anchor" id="module_create_sec"></a>
Implementing a Module</h2>
<p>We now discuss how to implement a new module. Using the above example, imagine that a developer has already written and debugged several subclasses of <a class="el" href="classMcMd_1_1Species.html" title="A Species represents a set of chemically similar molecules.">Species</a> and <a class="el" href="classMcMd_1_1McMove.html" title="McMove is an abstract base class for Monte Carlo moves.">McMove</a>, as well as two associated factory classes named StarSpeciesFactory and StarMcMoveFactory. He or she now wants to bundle these two factories into a <a class="el" href="classMcMd_1_1McModule.html" title="Abstract Module for an McSimulation.">McModule</a> named StarMcModule. The required definition of McStarModule might look like this: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>McMd
{

   <span class="keyword">class </span>McStarModule : <span class="keyword">public</span> McModule 
   {

   <span class="keyword">public</span>:

      McStarModule(McSimulation&amp; simulation);

      McStarModule();

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> addFactories();

   <span class="keyword">private</span>:

      Factory&lt;Species&gt;* speciesFactoryPtr_;

      Factory&lt;McMove&gt;*  mcMoveFactoryPtr_;

   }

}
</pre></div><p> with a minimal implementation </p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>McMd
{

   <span class="comment">// Constructor</span>
   StarModule::StarModule(McSimulation&amp; simulation)
    : McModule(simulation),
      speciesFactoryPtr_(0),
      mcMoveFactoryPtr_(0)
   {
      speciesFactoryPtr_ = <span class="keyword">new</span> StarSpeciesFactory(simulation);
      mcMoveFactoryPtr_  = <span class="keyword">new</span> StarMcMoveFactory(simulation);
   }

   <span class="comment">// Destructor</span>
   StarModule::StarModule()
   {
      <span class="keyword">delete</span> speciesFactoryPtr_;
      <span class="keyword">delete</span> mcMoveFactoryPtr_;
   }

   StarModule::addFactories()
   {
      simulation().speciesFactory().addSubfactory(*speciesFactoryPtr_);
      simulation().mcMoveFactory().addSubfactory(*mcMoveFactoryPtr_);
   }

}
</pre></div><p> Here, the StarMcModule constructor creates one instance of each of the two required factory classes, which are deleted in the destructor. The addFactories() method must then add each of these factories as a subfactory to a default factory owned by the main simulation object, using the appropriate accessors and addSubfactory() methods of the default factory objects.</p>
<p>The main benefit of writing a module is that it encapsulates the creation and destruction of several closely related factory objects, and allows a user to add these factories to a simulation with a single line of code. The creation of a module class can be convenient, but is not necessary.</p>
<ul>
<li>
<a class="el" href="potentials_page.html">Potential Energy Classes</a> (Previous)  </li>
<li>
<a class="el" href="extend_page.html">Extending Simpatico</a> (Up)  </li>
</ul>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 31 2012 22:26:38 for Simpatico by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
