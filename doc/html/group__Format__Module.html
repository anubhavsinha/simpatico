<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Simpatico: Output Format</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simpatico&#160;<span id="projectnumber">v1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Output Format</h1>  </div>
<div class="ingroups"><a class="el" href="group__Util__NS__Module.html">Util namespace</a></div></div>
<div class="contents">
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Utilities to simplify formatted C++ stream output. </p>
<p>This module provides wrapper classes that can simplify formatted output of the primitive data types with controllable field width and floating point precision.</p>
<h2><a class="anchor" id="Wrapper"></a>
Classes</h2>
<p>The classes <a class="el" href="classUtil_1_1Int.html" title="Wrapper for an int, for formatted ostream output.">Int</a>, <a class="el" href="classUtil_1_1Lng.html" title="Wrapper for a long int, for formatted ostream output.">Lng</a>, <a class="el" href="classUtil_1_1Dbl.html" title="Wrapper for a double precision number, for formatted ostream output.">Dbl</a>, <a class="el" href="classUtil_1_1Bool.html" title="Wrapper for an bool value, for formatted ostream output.">Bool</a>, and <a class="el" href="classUtil_1_1Str.html" title="Wrapper for a std::string, for formatted ostream output.">Str</a> are wrappers for outputting the data types int, long double, bool, and std::string, respectively. An inserter (&lt;&lt;) operator is defined for each such wrapper class that produces formatted output of the enclosed data with a controllable field width and (for <a class="el" href="classUtil_1_1Dbl.html" title="Wrapper for a double precision number, for formatted ostream output.">Dbl</a>) precision. Each wrapper class has a member variable of the associated data type and an integer field width member. The <a class="el" href="classUtil_1_1Dbl.html" title="Wrapper for a double precision number, for formatted ostream output.">Dbl</a> class also has an integer precision member, to control floating point precision.</p>
<p>Example: We wish to output the elements of two double precision precision array named "A" and "B" in two column with a minimum field width of 20 characters for elements of A, with 10 digit precision, and 10 characters for elements of B, with 6 digit precision. The following code accomplishes this: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">double</span> A[10], B[10];

 <span class="comment">// ... code that assigns values to elements of A and B ...</span>

 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; 10; ++i) {
    std::cout &lt;&lt; Dbl(A[i], 20, 10) &lt;&lt; Dbl(B[i], 10, 6) &lt;&lt; std::endl;
 }
</pre></div><p> The <a class="el" href="classUtil_1_1Dbl.html" title="Wrapper for a double precision number, for formatted ostream output.">Dbl</a> constructor used in this snippet has the interface Dbl::Dbl(double value, int width, int precision). The use of wrapper classes allows one to control output format using an an interface that is more compact than the C++ iostream interace, and only slightly more verbose than that of the C fprint function.</p>
<p>Two or more constructors are provide for each wrapper class. Each class has a constructor that requires only the value of of the variable, while others require the value and field width or (as in the above example) the value, width and precision. If a field width or precision is not specified as a parameter to the constructor, it may be set after construction using setter functions.</p>
<p>When no value is specified for the field width or (for <a class="el" href="classUtil_1_1Dbl.html" title="Wrapper for a double precision number, for formatted ostream output.">Dbl</a>) the precision, default values are used. The default width and precision for all data types are given by <a class="el" href="classUtil_1_1Format.html#ac6cf6620e160c66757429bec0fb4dd23" title="Return the default output field width.">Format::defaultWidth()</a> and <a class="el" href="classUtil_1_1Format.html#ad09d93166bbb678297938e83a88bab9a" title="Return the default output precision.">Format::defaultPrecision()</a>. These default values may be modified using the static methods <a class="el" href="classUtil_1_1Format.html#ac74f4b64bc83811fcd5e5f1a13b1e87f" title="Set the default output field width.">Format::setDefaultWidth()</a> and <a class="el" href="classUtil_1_1Format.html#a8af41659ebb3de8137359e1a4a4947f7" title="Set the default output precision.">Format::setDefaultPrecision()</a>.</p>
<p>Example: Suppose we wish to output the two column array described in the previous example, but are willing to use a 15 column field an 7 digits of precision for both columns. This could also be accomplished as follows: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">double</span> A[10], B[10];

 <a class="code" href="classUtil_1_1Format.html#ac74f4b64bc83811fcd5e5f1a13b1e87f" title="Set the default output field width.">Format::setDefaultWidth</a>(15);
 <a class="code" href="classUtil_1_1Format.html#a8af41659ebb3de8137359e1a4a4947f7" title="Set the default output precision.">Format::setDefaultPrecision</a>(7);

 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; 10; ++i) {
    std::cout &lt;&lt; Dbl(A[i]) &lt;&lt; Dbl(B[i]) &lt;&lt; std::endl;
 }
</pre></div><p> The setDefaultWidth() and setDefaultPrecision() functions are not needed if one is happy with the initial default settings, which are a width of 20 characters and a precision of 12.</p>
<h2><a class="anchor" id="Write"></a>
Function Template</h2>
<p>The <a class="el" href="namespaceUtil.html#af0997c7257e2ef413f70fdd3e9eeaa4f" title="Explicit specialization of write for double data.">write()</a> function template provides a generic interface for formatting ostream output, which can be used within a class or function template to output data for which the type is a template parameter. The wrapper classes cannot be used directly in this situation, because they require that an object of the appropriate wrapper class be specified explicitly. To output a variable data to an ostream out, one calls write(out, data). An explicit specialization of <a class="el" href="namespaceUtil.html#af0997c7257e2ef413f70fdd3e9eeaa4f" title="Explicit specialization of write for double data.">write()</a> is provided for each data type for which there exists a wrapper class. Each explicit specialization uses the corresponding wrapper class internally to format the output. Thus, if variable data is an int, write(out, data) is equivalent to out &lt;&lt; Int(data). For other data types, for which there exists no wrapper class, write(out, data) is equivalent out &lt;&lt; data. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1Bool.html">Util::Bool</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for an bool value, for formatted ostream output.  <a href="classUtil_1_1Bool.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1Dbl.html">Util::Dbl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for a double precision number, for formatted ostream output.  <a href="classUtil_1_1Dbl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1Format.html">Util::Format</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for output wrappers for formatted C++ ostream output.  <a href="classUtil_1_1Format.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1Int.html">Util::Int</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for an int, for formatted ostream output.  <a href="classUtil_1_1Int.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1Lng.html">Util::Lng</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for a long int, for formatted ostream output.  <a href="classUtil_1_1Lng.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1Str.html">Util::Str</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for a std::string, for formatted ostream output.  <a href="classUtil_1_1Str.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Format__Module.html#gaabeeaafc2872bcd5428befc5da1b532b">Util::write</a> (std::ostream &amp;out, Type data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function template for output in a standard format.  <a href="#gaabeeaafc2872bcd5428befc5da1b532b"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaabeeaafc2872bcd5428befc5da1b532b"></a><!-- doxytag: member="Util::write" ref="gaabeeaafc2872bcd5428befc5da1b532b" args="(std::ostream &amp;out, Type data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function template for output in a standard format. </p>
<p>The write function template is designed to simplify formatted stream output of variables within class and function template, when the typename of a variable is a template parameter.</p>
<p>The primary template implementation simply invokes the insertion &lt;&lt; operator for the specified type. For types controlled by the primary template (i.e., those for which no explicit specialization is provided) the expression write(out, data) is equivalent to out &lt;&lt; data.</p>
<p>Explicit specializations of this method are provided for int, long, double, bool, and string. Each of these uses an appropriate wrapper class (<a class="el" href="classUtil_1_1Int.html" title="Wrapper for an int, for formatted ostream output.">Int</a>, <a class="el" href="classUtil_1_1Lng.html" title="Wrapper for a long int, for formatted ostream output.">Lng</a>, <a class="el" href="classUtil_1_1Dbl.html" title="Wrapper for a double precision number, for formatted ostream output.">Dbl</a>, <a class="el" href="classUtil_1_1Bool.html" title="Wrapper for an bool value, for formatted ostream output.">Bool</a>, or <a class="el" href="classUtil_1_1Str.html" title="Wrapper for a std::string, for formatted ostream output.">Str</a>) to format output. For example, if data is an int, write(out, data) is equivalent to out &lt;&lt; Int(data). The width and (if appropriate) precision are controlled by <a class="el" href="classUtil_1_1Format.html#ac6cf6620e160c66757429bec0fb4dd23" title="Return the default output field width.">Format::defaultWidth()</a> and <a class="el" href="classUtil_1_1Format.html#ac6cf6620e160c66757429bec0fb4dd23" title="Return the default output field width.">Format::defaultWidth()</a>. </p>

<p>Definition at line <a class="el" href="write_8h_source.html#l00080">80</a> of file <a class="el" href="write_8h_source.html">write.h</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 31 2012 22:41:04 for Simpatico by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
