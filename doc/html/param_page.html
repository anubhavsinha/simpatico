<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Simpatico: Parameter File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simpatico&#160;<span id="projectnumber">v1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">Simpatico - Simulation Package for Polymer and Molecular Liquids</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Parameter File </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>All of the Simpatico programs use parameter files with a heirarchical file format. Each parameter file contains a set of nested blocks that begin and end with matched curly brackets, like blocks in a C program. As an example, we show a complete parameter file for a simple constant energy (NVE) MD simulation, for use with the default version of mdSim. Other example parameter files for mdSim, mcSim and ddSim can be found in the simpatico/examples/ directory.</p>
<h2><a class="anchor" id="param_example_section"></a>
Example</h2>
<div class="fragment"><pre class="fragment">MdSimulation{
  FileMaster{
    commandFileName               commands
    inputPrefix                        in/
    outputPrefix                      out/
  }
  nAtomType                              2
  nBondType                              1
  atomTypes                              A   1.000
                                         B   1.000
  maskedPairPolicy              MaskBonded
  SpeciesManager{

    Homopolymer{
      moleculeCapacity                     100
      nAtom                                  8
      atomType                               0
      bondType                               0
    }

    Homopolymer{
      moleculeCapacity                     100
      nAtom                                  8
      atomType                               0
      bondType                               0
    }

  }
  Random{
    seed                           10742892
  }
  MdSystem{
    pairStyle                        LJPair
    bondStyle                  HarmonicBond 
    MdPairPotential{
      epsilon               1.000000000000e+00  1.000000000000e+00
                            1.000000000000e+00  1.000000000000e+00
      sigma                 1.000000000000e+00  1.000000000000e+00
                            1.000000000000e+00  1.000000000000e+00
      cutoff                1.122460000000e+00  1.122460000000e+00
                            1.122460000000e+00  1.122460000000e+00
      maxBoundary           cubic       12.000   
      PairList{
        atomCapacity                        1000
        pairCapacity                       10000
        skin                  2.500000000000e-01
      }
    }
    BondPotential{
      kappa                 2.000000000000e+03
      length                1.000000000000e+00
    }
    EnergyEnsemble{
      type                        adiabatic
    }
    BoundaryEnsemble{
      type                            rigid
    }
    NveVvIntegrator{
       dt                   5.000000000000e-03
    }
  }
  DiagnosticManager{
    baseInterval                          10

    LogProgress{
      interval                          1000
    }

    DumpConfig{
      interval                          1000
      outputFileName                   dump/
    }

    MdEnergyOutput{
      interval                          1000
      outputFileName                  energy
    }

  }

}
</pre></div><h2><a class="anchor" id="param_format_section"></a>
Syntax</h2>
<p>A Simpatico parameter file, such as the above example, contains of a set of nested blocks. Each block is delimited by lines containing opening and closing curly brackets, much like the structure of a C program. Each block may contains lines that give values for individual simulation parameters, as well as nested sub-blocks. The order of appearance of elements within each block is for the most part fixed: The program will output a message indicating the nature of the error, and then stop parsing, if parameters or sub-blocks do not appear in the expected order.</p>
<p>The nesting of parameter blocks in this file format reflects the organization of C++ objects from which the simulation is constructed: All the C++ objects that must read parameters from file during initialization are organized into a hierarchy, or tree. Each object can have any number "child" objects, in addition to parameters. Every object except the root object has one "parent". A "child" object is generally either a member of its parent object, or a dynamically allocated object that the parent is responsible for creating and destroying. Each object in this hierarchy is responsible for reading an associated block in the parameter file, which contains all the parameters necessary to initialize that object, and must also invoke the functions that read parameter blocks associated with its children. The root node of this tree is the main simulation object, which is always an instance of <a class="el" href="classMcMd_1_1McSimulation.html" title="A Monte-Carlo simulation of one McSystem.">McMd::McSimulation</a> (for mcSim), <a class="el" href="classMcMd_1_1MdSimulation.html" title="A molecular dynamics simulation of a single MdSystem.">McMd::MdSimulation</a> (for ddSim) or <a class="el" href="classDdMd_1_1Simulation.html" title="Main object for a domain-decomposition MD simulation.">DdMd::Simulation</a> (for ddSim).</p>
<p>Each block in a parameter file begins with a line containing a class name, which is the class of the associated C++ object, followed by an opening brace ("{"). No white space may appear between the class name and the opening brace. For example, the block that initializes the "MdSystem" object in the above example begins with the line "MdSystem{". Each block ends with a line containing only a matched closing brace (i.e., "}"). By convention, nested blocks are indented, but indentation and other additional white space is ignored when the file is parsed. The main block, which contains all the others, is associated with the main simulation object.</p>
<p>The value of each parameter that is represented by a primitive C++ variable (e.g., an int, double, or bool) or by a std::string is given on a single line that contains a label followed by a parameter value. Each parameter is associated with a member variable of the enclosing class. By convention, each parameter label is the same as the name of the associated class member variable, except that the parameter labels does not contain the trailing underscore that is used in the Simpatico source code to mark names of private class member variables. For example, the number of atom types in an <a class="el" href="classMcMd_1_1MdSimulation.html" title="A molecular dynamics simulation of a single MdSystem.">MdSimulation</a> is given by private member variable named nAtomType_, which is indicated in the parameter file by a label "nAtomType". Label names (like C++ variable names) may not contain white space.</p>
<p>Some parameters correspond to variables that are defined in the source code as instances of non-primitive data types, such as enumerations or small classes. The value of each such variable is also given on a single line containing a label followed by a text representation of the value, as for primitive C/C++ types. In these cases, the text representation of the "value" of the variable must be defined by iostream extractor (&gt;&gt;) and insertor (&lt;&lt;) operators that have been defined for that data type. For example, in the above file, the "type" member of the EnergyEnsemble object is an instance of the enumeration <a class="el" href="classUtil_1_1EnergyEnsemble.html#a7685d5a360ecfeda650262a9b7c56640" title="Enumeration of the allowed types of EnergyEnsemble.">EnergyEnsemble::Type</a>. This enum can have values ADIABATIC (constant energy) or ISOTHERMAL (constant temperature). The value of this variable is read by an overloaded extractor (&gt;&gt;) operator that recognizes both "adiabatic" or "ADIABATIC" as valid string representations of one of the allowed enum values.</p>
<p>Some parameters are represented internally by one-dimensional arrays. An array of parameters is represented in the parameter file by a sequence of lines in which the first line contains the label (the name of the array) and the value of the first element, while subsequent lines contain values of subsequent elements. Thus, for example, the atomTypes member of an <a class="el" href="classMcMd_1_1MdSimulation.html" title="A molecular dynamics simulation of a single MdSystem.">MdSimulation</a> is an array (a DArray &lt; <a class="el" href="classMcMd_1_1AtomType.html" title="Descriptor for a type of Atom.">AtomType</a> &gt; container) that contains nAtomType instances of class <a class="el" href="classMcMd_1_1AtomType.html" title="Descriptor for a type of Atom.">AtomType</a>. The string representation of an <a class="el" href="classMcMd_1_1AtomType.html" title="Descriptor for a type of Atom.">AtomType</a>, which is defined by the extractor (&gt;&gt;) operator for an <a class="el" href="classMcMd_1_1AtomType.html" title="Descriptor for a type of Atom.">AtomType</a>, contains a name string ("A" or "B" in this example) followed by a floating point mass. (The mass is 1.0 for both of the types in this example). This array is input using a format in which the first line contains the label "atomTypes" (the name of the array), and in which this and each subsequent line contains a string representation of one <a class="el" href="classMcMd_1_1AtomType.html" title="Descriptor for a type of Atom.">AtomType</a> object. The number of elements in such an array (nAtomType in this example) must be known before the array is read. In this case, the number of elements in the atomTypes array is given by the value of "nAtomType", which must thus appear before the "atomTypes" array in the file format.</p>
<p>Variables that are stored in two-dimensional arrays or Matrix objects also use a multi-line format. In this case, the first line contains a label (the name of the associated matrix), followed by the elements of the first row, with subsequent rows on subsequent lines. In the above example, this format is used for the epsilon, sigma, and cutoff members of an LJPair pair potential object. Each of these parameters is represented internally as a two dimensional array, in which epsilon[i][j] is the value of the Lennard-Jones epsilon parameter for interactions between atoms of types i and j, for 0 &lt; i, j &lt;= nAtomType.</p>
<p>The meaning of most parameter labels should be self-explanatory. When they are not, the file format makes it easy to look up the meaning of the variable in the html documentation or source code: Each parameter in this file format is labelled by the name of an associated member variable of a class that is identified by the class name in the first line of the intermost enclosing block. The meaning of any parameter can thus be looked up by looking up the member variable identified by the parameter label in the html documentation and/or *.h header file of the enclosing class.</p>
<p>To use this file format, it useful to know a little about how it is parsed. As already noted, each block in a parameter file is associated with an object that is an instance of the class that is named in the opening line of the block. Every such class must a subclass of the abstract base class <a class="el" href="classUtil_1_1ParamComposite.html" title="An object that can read multiple parameters from file.">Util::ParamComposite</a>, and must provide an implementation for the method </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classUtil_1_1ParamComposite.html#a1a5c30a9916a5392fedc26f93b8c8724" title="Read all parameters from an input stream.">Util::ParamComposite::readParam</a>(std::istream&amp;) = 0;
</pre></div><p> which is declared as a pure virtual method in the definition of ParamComposite. Each block in the file is parsed by the readParam method of the associated class. The opening line for an object of class Foo, which contains the string "Foo{", marks the spot at which the code enters the function Foo:readParam(), and the line containing the closing bracket "}" marks the point at which Foo::readParam() returns.</p>
<p>The implementation of the readParam() method of a class defines the order in which parameter and any sub-blocks must appear in the associated parameter file block. The most reliable documentation of the file format for each parameter file block is thus the source code of the readParam() method of the class named in the opening line of the block. An explanation of the programming conventions used in all such readParam() methods is given <a class="el" href="read_param_page.html">here</a>. The readParam() method of each class must read whatever data is required to initialize an instance of that class. It must also invoke the readParam() method of each of its "child" objects, each of which is associated with a subblock in the parameter file. This algorithm is an example of the so-called "Composite" programming pattern (<a href="http://en.wikipedia.org/wiki/Composite_pattern">http://en.wikipedia.org/wiki/Composite_pattern</a>).</p>
<h2><a class="anchor" id="polymorphic_section"></a>
Polymorphic Blocks</h2>
<p>Some parameter file blocks are "polymorphic". A polymorphic block is one that may represent any of several possible subclasses of a particular base class, and may contain the file format appropriate for any such subclass. When a polymorphic block is encountered, the parent object must recognize which subclass of the relevant base class is desired from the class name in the opening line of the block.</p>
<p>For example, in an mdSim simulation, the <a class="el" href="classMcMd_1_1MdSystem.html" title="A System for Molecular Dynamics simulation.">MdSystem</a> object has an associated <a class="el" href="classMcMd_1_1MdIntegrator.html" title="Abstract base for molecular dynamics integrators.">MdIntegrator</a> object. The user may specify that this object should an instance of either <a class="el" href="classMcMd_1_1NveVvIntegrator.html" title="An NVE Verlet molecular dynamics integrator.">NveVvIntegrator</a>, a class that implements an energy conserving NVE velocity-Verlet integrator, or an instance of <a class="el" href="classMcMd_1_1NvtNhIntegrator.html" title="A Nose-Hoover NVT molecular dynamics integrator.">NvtNhIntegrator</a>, an isothermal NVT Nose-Hoover integrator, among other choices. Each of the available integrator algorithms is implemented as a subclasses of the abstract base class <a class="el" href="classMcMd_1_1MdIntegrator.html" title="Abstract base for molecular dynamics integrators.">MdIntegrator</a>. The parameter file block associated with the <a class="el" href="classMcMd_1_1MdIntegrator.html" title="Abstract base for molecular dynamics integrators.">MdIntegrator</a> object may contain the file format for any of the available subclasses of <a class="el" href="classMcMd_1_1MdIntegrator.html" title="Abstract base for molecular dynamics integrators.">MdIntegrator</a>. If an <a class="el" href="classMcMd_1_1NveVvIntegrator.html" title="An NVE Verlet molecular dynamics integrator.">NveVvIntegrator</a> block is encountered, as in the above example file, the parent <a class="el" href="classMcMd_1_1MdSystem.html" title="A System for Molecular Dynamics simulation.">MdSystem</a> will create and initialize an <a class="el" href="classMcMd_1_1NveVvIntegrator.html" title="An NVE Verlet molecular dynamics integrator.">NveVvIntegrator</a> object. To indicate that an <a class="el" href="classMcMd_1_1NvtNhIntegrator.html" title="A Nose-Hoover NVT molecular dynamics integrator.">NvtNhIntegrator</a> was desired instead, this block in the parameter file could be changed to contain the file format for an <a class="el" href="classMcMd_1_1NvtNhIntegrator.html" title="A Nose-Hoover NVT molecular dynamics integrator.">NvtNhIntegrator</a>, which would begin with the line "NvtNhIntegrator{".</p>
<p>Because different subclasses of <a class="el" href="classMcMd_1_1MdIntegrator.html" title="Abstract base for molecular dynamics integrators.">MdIntegrator</a> may require different parameters, each subclass defines its own parameter file format. For example, the format for an <a class="el" href="classMcMd_1_1NvtNhIntegrator.html" title="A Nose-Hoover NVT molecular dynamics integrator.">NvtNhIntegrator</a> contains a parameter that controls the strength of the coupling of the system to a heat reservoir, which is not needed in an <a class="el" href="classMcMd_1_1NveVvIntegrator.html" title="An NVE Verlet molecular dynamics integrator.">NveVvIntegrator</a>.</p>
<p>When the first line of a polymorphic block is encountered, the readParam() of the parent object must compare the subclass name that appears in the opening line to a list of known subclasses of the corresponding base class. In this example, it must recognize "NveVvIntegrator" as a valid name of a subclass of "MdIntegrator". If it recognizes the subclass name, it creates a new instance of the desired subclass and then invokes the readParam method of this new instance to read the rest of the block. The algorithm used to process a polymorphic block relies on an associated "Factory" class that is responsible for recognizing the name of any subclass of the relevant base class, and instantiating objects of any such subclass, as discussed in more detail <a class="el" href="factory_page.html">here</a>.</p>
<h2><a class="anchor" id="manager_section"></a>
Manager Classes</h2>
<p>The above example file contains blocks labelled "SpeciesManager" and "DiagnosticManager", which are examples of Manager classes. A Manager is a container that holds an array of pointers to dynamically allocated objects that are all instances of subclasses of specific base class. Thus, for example, a <a class="el" href="classMcMd_1_1SpeciesManager.html" title="A Manager for a set of Species objects.">SpeciesManager</a> hold an array of Species* pointers to <a class="el" href="classMcMd_1_1Species.html" title="A Species represents a set of chemically similar molecules.">Species</a> objects (i.e., instances of the <a class="el" href="classMcMd_1_1Species.html" title="A Species represents a set of chemically similar molecules.">Species</a> base class or its subclasses) that represent different molecular species within a mixture. A <a class="el" href="classMcMd_1_1DiagnosticManager.html" title="Manager for a list of Diagnostic objects.">DiagnosticManager</a> contains an array of pointers to <a class="el" href="classMcMd_1_1Diagnostic.html" title="Abstract base for periodic output and/or analysis actions.">Diagnostic</a> objects that will be used for data analysis and/or data output during a simulation. A Monte Carlo simulation also has an <a class="el" href="classMcMd_1_1McMoveManager.html" title="Manager for a set of McMove objects.">McMoveManager</a> that contains an array of pointers to <a class="el" href="classMcMd_1_1McMove.html" title="McMove is an abstract base class for Monte Carlo moves.">McMove</a> objects that implement different Markov MC moves.</p>
<p>The parameter file block associated with a Manager class contains a sequence of subblocks, separated by spaces. Each of the subblocks is polymorphic: Each subblock may contain the file format for any known subclass of the associated base class. The parameter file block associated with an <a class="el" href="classMcMd_1_1DiagnosticManager.html" title="Manager for a list of Diagnostic objects.">DiagnosticManager</a> thus contains sub blocks that represent different subclasses of <a class="el" href="classMcMd_1_1Diagnostic.html" title="Abstract base for periodic output and/or analysis actions.">Diagnostic</a> that should be used for data analysis during a simulation. The readParam method of a Manager class is responsible for reading a sequence of such polymorphic subblocks, instantiating one object of the indicated subclass for each subblock, and appending a base class pointer to each new object to an array of such pointers.</p>
<h2><a class="anchor" id="potential_section"></a>
Potential Energies</h2>
<p>In both MD and MC simulations, a <a class="el" href="classMcMd_1_1System.html" title="A set of interacting Molecules enclosed by a Boundary.">System</a> has several associated types of potential energy. By default, these include only a non-bonded pair potential and a bond potential. Other types of potential energy that are disabled by default, such as 3-body bond angle and 4-body dihedral potentials, may be enabled by setting associated flags INTER_ANGLE and INTER_DIHEDRAL in the file inter/defines.mk before compiling.</p>
<p>For each type of potential energy, the user must choose from several forms for the potential energy function by specifying a "style" parameter string. For example, the type of nonbonded pair potential function is specified by the value of "pairStyle". This can take on values "LJPair", corresponding to a Lennard-Jones potential, or "DpdPair", corresponding to the soft potential typically used in dissipative particle dynamics (DPD) simulations. Each of the allowed values of this "style" string corresponds to the name of a class in the src/inter/pair directory that implements the core calculation of energy and/or force for a single pair of nonbonded atoms. We will refer to such classes as pair "interaction" classes. Similarly, "bondStyle" can take on values "HarmonicBond" or "FeneBond", which are the names of bond interaction classes in src/inter/bond directory.</p>
<p>In the above example, the "pairStyle" and "bondStyle" parameters appear near the top of the <a class="el" href="classMcMd_1_1MdSystem.html" title="A System for Molecular Dynamics simulation.">MdSystem</a> block. The parameter file format for a code compiled with angle and dihedral potentials enabled would also contain "angleStyle" and "dihedralStyle" strings that specify choices of angle and dihedral interaction classes.</p>
<p>These "style" variables are followed by a set of blocks that contain the parameters for different types of potential energy (pair, bond, etc.). In the above example, these blocks are labelled "MdPairPotential" and "BondPotential". Each of these blocks contains the set of parameters required by the potential energy function specified by the corresponding "style" variable.</p>
<p>Two different classes named <a class="el" href="classMcMd_1_1MdPairPotential.html" title="An PairPotential for MD simulation.">MdPairPotential</a> and <a class="el" href="classMcMd_1_1McPairPotential.html" title="A PairPotential for MC simulations (abstract).">McPairPotential</a> are used to represent the pair potential in MD and MC simulations, respectively. Different classes are used for the pair potential in MD and MC simulation because different data structures are used to keep track of neighbors in MD and MC simulations. In the above example, the <a class="el" href="classMcMd_1_1MdPairPotential.html" title="An PairPotential for MD simulation.">MdPairPotential</a> parameter block contains not only the parameters required by the associated interaction (epsilon, sigma, and cutoff for the LJPair Lennard-Jones style), but also a parameter labelled maxBoundary and a <a class="el" href="classMcMd_1_1PairList.html" title="A Verlet neighbor list.">PairList</a> sub-block. These additional parameters are required to create a Verlet pairlist, which is needed to efficiently compute pair interactions in an MD simulation. The corresponding classes <a class="el" href="classMcMd_1_1McPairPotential.html" title="A PairPotential for MC simulations (abstract).">McPairPotential</a> contains the parameters that are required to create a cell list, but does not contain a <a class="el" href="classMcMd_1_1PairList.html" title="A Verlet neighbor list.">PairList</a> subblock.</p>
<p>For covalent bonded interactions, the same class is used in MD and MC simulations. The class name for the object that represents a bond potential is thus simply called <a class="el" href="classMcMd_1_1BondPotential.html" title="Abstract Bond Potential class.">BondPotential</a>, rather than MdBondPotential or McBondPotential. The file format for a code compiled with angle and dihedral potentials would contains subsequent <a class="el" href="classMcMd_1_1AnglePotential.html" title="Interface for a Angle Interaction.">AnglePotential</a> and <a class="el" href="classMcMd_1_1DihedralPotential.html" title="Interface for a Dihedral Potential.">DihedralPotential</a> blocks, each of which contains the parameters for the potential energy style specified by the associated angleStyle or dihedralStyle string.</p>
<ul>
<li>
<a class="el" href="usage_page.html">Usage</a> (Prev)  </li>
<li>
<a class="el" href="guide_page.html">User Guide</a> (Up)  </li>
<li>
<a class="el" href="commands_page.html">Command File</a> (Next)  </li>
</ul>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 31 2012 22:26:38 for Simpatico by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
