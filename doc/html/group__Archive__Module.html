<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Simpatico: Archives</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simpatico&#160;<span id="projectnumber">v1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<h1>Archives</h1>  </div>
<div class="ingroups"><a class="el" href="group__Serialize__Module.html">Serialization</a></div></div>
<div class="contents">
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>An archive stores serialized data, either in a file or in RAM. </p>
<p>The definition of an archive used here is very similar to that used in the Boost serialization library. An archive class may model either a saving / output archive, to which data is saved, or a loading / input archive, from which data is loaded. By convention, the names of saving/output archive classes end with the string OArchive and the names of loading/input archive classes end with the string IArchive. Different archive classes store serialized objects in different forms. For example, <a class="el" href="classUtil_1_1TextFileOArchive.html" title="Saving archive for character based ostream.">TextFileOArchive</a> and <a class="el" href="classUtil_1_1TextFileIArchive.html" title="Saving archive for binary istream.">TextFileIArchive</a> are saving and loading archive classes, respectively, that are wrappers for ofstream or ifstream file stream objects in which data is stored in a character representation. <a class="el" href="classUtil_1_1BinaryFileOArchive.html" title="Saving archive for binary ostream.">BinaryFileOArchive</a> and <a class="el" href="classUtil_1_1BinaryFileIArchive.html" title="Saving archive for binary istream.">BinaryFileIArchive</a> are saving/output and loading / input archives that store data in a binary format. <a class="el" href="classUtil_1_1MemoryOArchive.html" title="Save archive for packed heterogeneous binary data.">MemoryOArchive</a> and <a class="el" href="classUtil_1_1MemoryIArchive.html" title="Input archive for packed heterogeneous binary data.">MemoryIArchive</a> are saving and loading archives that stored data in binary form in a block of random-access memory.</p>
<p>Objects may be saved to a saving archive or loaded from a loading archive using overloaded operators, using the same syntax as that of the Boost library. Each saving archive class must define method templates that overload the &lt;&lt; (insertion) and &amp; operators. These overloaded operators must be equivalent, and must save an object to the archive. If ar is an instance of a saving archive, such as <a class="el" href="classUtil_1_1BinaryFileOArchive.html" title="Saving archive for binary ostream.">BinaryFileOArchive</a>, the expressions </p>
<div class="fragment"><pre class="fragment">    ar &lt;&lt; data; 
    ar &amp;  data;
</pre></div><p> are thus equivalent, and both save the state of variable data into archive ar. Each loading archive class must instead define template methods to overload the &gt;&gt; (extractor) and &amp; operator, which must be equivalent, and which must load an object from the archive. If ar is an instance of a loading archive, such as <a class="el" href="classUtil_1_1BinaryFileIArchive.html" title="Saving archive for binary istream.">BinaryFileIArchive</a>, then the expressions </p>
<div class="fragment"><pre class="fragment">    ar &gt;&gt; data;
    ar &amp;  data;
</pre></div><p> are equivalent, and both load the state of variable data from archive ar.</p>
<p>Objects of type T can be saved to or loaded from an instance of a class Archive if and only if the compiler can find a function named serialize with the signature </p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">void</span> <a class="code" href="namespaceUtil.html#af9a860e1bc8eea0959fd8c3f4f60b86c" title="Load a std::string from a BinaryFileIArchive.">serialize</a>(Archive&amp; ar, T&amp; data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> version)
</pre></div><p> Here, "version" is an integer index that indicates the version of the archive. This version id is normally given by an integer member of the archive class. The operator &amp; for a class Archive is normally implemented by a method template </p>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
  <span class="keywordtype">void</span> Archive::operator &amp; (T&amp; data);
  {  <a class="code" href="namespaceUtil.html#af9a860e1bc8eea0959fd8c3f4f60b86c" title="Load a std::string from a BinaryFileIArchive.">serialize</a>(*<span class="keyword">this</span>, data, version_); }
</pre></div><p> that simply calls the appropiate serialize method. Here, version_ is an integer member of the Archive class that stores the archive version id. Similar templates must be provided for the &lt;&lt; or &gt;&gt; operator.</p>
<p>Each archive class provides serialize functions for all of the built-in C/C++ types, as well as few other common data types such as std::string. Definitions of the serialize function for saving archive types must save (write) data, and those for loading archive types must load (read) data.</p>
<p>Instances of user-defined classes may also be serialized if an appropriate serialize function can be found by the compiler. Serialization of instances of a class T may be enabled by defining either:</p>
<ul>
<li>A global serialize function template, with a signature <div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;
 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceUtil.html#af9a860e1bc8eea0959fd8c3f4f60b86c" title="Load a std::string from a BinaryFileIArchive.">serialize</a>(Archive&amp; ar, T&amp; data, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> version);
</pre></div></li>
</ul>
<ul>
<li>A serialize method template in class T, with a signature <div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;
 <span class="keywordtype">void</span> <a class="code" href="namespaceUtil.html#af9a860e1bc8eea0959fd8c3f4f60b86c" title="Load a std::string from a BinaryFileIArchive.">T::serialize</a>(Archive&amp; ar, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> version);
</pre></div> Note that, in either case, the archive type is normally a template parameter, so that the same serialize function can work with multiple types of archives.</li>
</ul>
<p>In order to use this system, it is worth understanding how the compiler finds an appropriate serialize method. When the C++ compiler needs a serialize method for a particular archive type Archive and data type T, it will look first for a function <a class="el" href="namespaceUtil.html#a3b4ab759eba45a5e988a0b65cd5828ef" title="Serialize one object of type T.">serialize(Archive&amp;, T&amp;, unsigned int)</a> with exactly the required signature, and then for an appropriate template. Such functions are provided for each archive classes for all of the built-in C/C++ types, and are always used to serialize such types. For class types, their is normally no such non-template function, and so the compiler will look for an appropriate template, giving priority to templates in which fewer of the function parameters have types given by template arguments, rather than explicit types. If the compiler has access to a global serialize function template for class T with the signature described above, in which the archive type is a template parameter but the data type T is explicit, it will use this. If no such global serialize function template is found, the compiler will try to compile the following generic template, </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive, <span class="keyword">typename</span> T&gt;
 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceUtil.html#af9a860e1bc8eea0959fd8c3f4f60b86c" title="Load a std::string from a BinaryFileIArchive.">serialize</a>(Archive&amp; ar, T&amp; data, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> version)
 {  data.serialize(ar, version); }
</pre></div><p> which is defined in the file src/util/serialize.h. This template simply calls the serialize method of class T, and so will not compile if no such method exists. The compiler can thus use, in decreasing order of priority: 1) An explicit serialize function for type T and a specific archive type, 2) A serialize function template for a specific type T in which the archive type is a template parameter, or 3) A serialize method of class T in which the archive type is a template parameter. If none of these are accessible for class T, compilation will fail for any code that attempts to serialize an instance of class T.</p>
<p>The use of a single operator &amp; to represent both output (when applied to a saving archive) and input (when applied to a loading archive), makes it possible to write a single serialize function template for each class that specifies how to order save or load instances of that class, by specifying the order in which members of the class are serialized. For example, consider the following definition of a simple complex number class: </p>
<div class="fragment"><pre class="fragment">   <span class="keyword">class </span>Complex  {
   <span class="keyword">public</span>:

      A(<span class="keywordtype">double</span> real, <span class="keywordtype">double</span> imag) : real_(real), imag_(imag) {}
 
      <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;
      <span class="keywordtype">void</span> <a class="code" href="namespaceUtil.html#af9a860e1bc8eea0959fd8c3f4f60b86c" title="Load a std::string from a BinaryFileIArchive.">serialize</a>(Archive&amp; ar, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> version)
      { 
         ar &amp; real_;
         ar &amp; imag_:
      }

   <span class="keyword">private</span>:

      <span class="keywordtype">double</span> real_;
      <span class="keywordtype">double</span> imag_;   
 
   } 
</pre></div><p> The serialize method template provides instructions for the order in which to either save the two floating point members of the class to a saving archive, or to load them from a loading archive. The use of a template in which the archive type is a parameter allows a single serialize method to be used with any type of saving or loading archive.</p>
<p>The most serious disadvantage of this system is that, if the serialize method is defined by a template, it cannot also be a virtual method. As a result, the serialize method template for a class cannot be accessed polymorphically, via a pointer or reference to a base class. This limitation becomes a problem in designs in which some objects are accessed only via base class pointers. The <a class="el" href="classUtil_1_1Serializable.html" title="Abstract class for serializable objects.">Serializable</a> abstract base class, discussed below, partially solves this problem, by replacing the serialize method template by a pair of virtual save() and load() methods. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1BinaryFileIArchive.html">Util::BinaryFileIArchive</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving archive for binary istream.  <a href="classUtil_1_1BinaryFileIArchive.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1BinaryFileOArchive.html">Util::BinaryFileOArchive</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving archive for binary ostream.  <a href="classUtil_1_1BinaryFileOArchive.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1MemoryIArchive.html">Util::MemoryIArchive</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Input archive for packed heterogeneous binary data.  <a href="classUtil_1_1MemoryIArchive.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1MemoryOArchive.html">Util::MemoryOArchive</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save archive for packed heterogeneous binary data.  <a href="classUtil_1_1MemoryOArchive.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1TextFileIArchive.html">Util::TextFileIArchive</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving archive for binary istream.  <a href="classUtil_1_1TextFileIArchive.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1TextFileOArchive.html">Util::TextFileOArchive</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving archive for character based ostream.  <a href="classUtil_1_1TextFileOArchive.html#_details">More...</a><br/></td></tr>
</table>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Aug 29 2012 08:57:58 for Simpatico by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
