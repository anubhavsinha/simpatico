<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Simpatico: Factory Classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simpatico&#160;<span id="projectnumber">v1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">Simpatico - Simulation Package for Polymer and Molecular Liquids</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Factory Classes </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="factory_purpose"></a>
Why Factory Classes Exist</h2>
<p>The Simpatico parameter file format allows users to choose at run time from among subclasses of each the extensible base classes, and thereby choose particular molecular species, file formats, and algorithms for use in a simulation. This is done primarily by using polymorphic blocks in the parameter file format. A polymorphic block is a block in the parameter file that may contain the file format for any of a set of known subclasses of a particular base class. The desired subclass is identified by the class name in the first line of such a block. The code which parse a polymorphic block must somehow recognize this string as the name of a valid subclass. The algorithm used to parse these relies on the definition of an associated Factory class. A Factory class is responsible for recognizing the name of any valid subclass of a particular base class, and can instantiate an object of any such base class. Thus, for example, the <a class="el" href="classMcMd_1_1MdIntegratorFactory.html" title="Default Factory for subclasses of MdIntegrator.">MdIntegratorFactory</a> class is responsible for parsing the polymorphic block that contains the parameters for an <a class="el" href="classMcMd_1_1MdIntegrator.html" title="Abstract base for molecular dynamics integrators.">MdIntegrator</a> for an MD simulation. The</p>
<p>The implementation of the Factory class associated with a base class defines the set of known subclasseses of that base class that can appear in a parameter file. Simpatico provides a default implementation of each of each Factory class, each of which will recognize the names of any of the subclasses that are distributed with Simpatico. This default implementation is usually located in the subdirectory of the src/ directory that contains these subclasses.</p>
<p>To allow a user-defined subclass of one of the base classes to be specified in the parameter file, the developer of a new subclass must somehow add the new class to the set that will be recognized by the associated Factory. This page provides intructions for how to do that.</p>
<h2><a class="anchor" id="factory_structure_sec"></a>
Factory Class Structure</h2>
<p>Each Factory class provides a method that takes the name of a subclass as a string. If this method can match the string to the name of a known subclass of the associated base class, it instantiates a new object of the desired subclass, and returns a pointer to the new object.</p>
<p>The Factory class associated with a class named "Base" (where "Base" could be <a class="el" href="classMcMd_1_1McMove.html" title="McMove is an abstract base class for Monte Carlo moves.">McMove</a>, <a class="el" href="classMcMd_1_1MdIntegrator.html" title="Abstract base for molecular dynamics integrators.">MdIntegrator</a>, <a class="el" href="classMcMd_1_1Diagnostic.html" title="Abstract base for periodic output and/or analysis actions.">Diagnostic</a>, etc.) is usually derived from the class template <a class="el" href="classUtil_1_1Factory.html" title="Factory template.">Util::Factory</a> &lt; Base &gt;. For example, <a class="el" href="classMcMd_1_1McMoveFactory.html" title="McMoveFactory for an McSimulation.">McMoveFactory</a> is derived from the template instantiation <a class="el" href="classUtil_1_1Factory.html" title="Factory template.">Util::Factory</a> &lt; <a class="el" href="classMcMd_1_1McMove.html" title="McMove is an abstract base class for Monte Carlo moves.">McMove</a> &gt;. The <a class="el" href="classUtil_1_1Factory.html" title="Factory template.">Util::Factory</a> template declares a pure virtual method named factory() with the following interface. </p>
<div class="fragment"><pre class="fragment">   <span class="keyword">template</span> &lt;<span class="keyword">class</span> Base&gt;
   Base* <a class="code" href="classUtil_1_1Factory.html#a75ae49003fb0b92da58e370ceae64153" title="Returns a pointer to a new instance of specified subclass.">Factory&lt;Base&gt;::factory</a>(<span class="keyword">const</span> std::string className) <span class="keyword">const</span> = 0;
</pre></div><p> This method take the name of a subclass of Base as a string parameter className. If the method recognizes this name, it creates a new instance of the specified subclass, and returns a Base* pointer to the new object. The pointer to the new object can then be used by the invoking function to read the associated parameter file block, by invoking the readParam() method of the new object. If the classname string is not recognized, the factory method returns a null pointer, and the program throws an Exception.</p>
<p>Each Factory can also contain a list of subfactories. Each subfactory of a Factory&lt;Base&gt; object is another Factory&lt;Base&gt; object that can recognize and instantiate a set of additional subclasses of Base. A Factory and its subfactories form a tree that is searched in a depth first manner: The factory() method of the default Factory for a particular base class such as <a class="el" href="classMcMd_1_1Species.html" title="A Species represents a set of chemically similar molecules.">Species</a> or <a class="el" href="classMcMd_1_1McMove.html" title="McMove is an abstract base class for Monte Carlo moves.">McMove</a> first calls the factory() method of each of its subfactories, before attempting to match the name against its own list of names. The Factory template provides an addSubfactory() method with the following signature: </p>
<div class="fragment"><pre class="fragment">   <span class="keyword">template</span> &lt;<span class="keyword">class</span> Base&gt;
   <span class="keywordtype">void</span> <a class="code" href="classUtil_1_1Factory.html#acc4e596c0a8636a5553ada58dfe898ce" title="Add a new subfactory to the list.">Factory&lt;Base&gt;::addSubfactory</a>(Factory&lt;Base&gt;&amp; subfactory);
</pre></div><p> This can be used to add a subfactory to a parent factory, in order to extend the set of subclasses that will be recognized by the parent factory.</p>
<p>As an example, consider the class <a class="el" href="classMcMd_1_1MdIntegratorFactory.html" title="Default Factory for subclasses of MdIntegrator.">MdIntegratorFactory</a> that is distributed with Simpatico, which is a subclass of <a class="el" href="classUtil_1_1Factory.html">Factory&lt;MdIntegrator&gt;</a>. Here is the code that defines the <a class="el" href="classMcMd_1_1MdIntegratorFactory.html#a311ab329444414f294a77e629df8047a" title="Method to create any species supplied with Simpatico.">MdIntegratorFactory::factory()</a> method: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;MdIntegratorFactory.h&quot;</span>

<span class="comment">// Subclasses of MdIntegrator </span>
<span class="preprocessor">#include &quot;NVEIntegrator.h&quot;</span>
<span class="preprocessor">#include &quot;NVTIntegrator.h&quot;</span>

<span class="keyword">namespace </span>McMd 
{

   MdIntegrator* <a class="code" href="classMcMd_1_1MdIntegratorFactory.html#a311ab329444414f294a77e629df8047a" title="Method to create any species supplied with Simpatico.">MdIntegratorFactory::factory</a>(std::string &amp;className)
   {
      MdIntegrator *ptr = 0;

      <span class="comment">// Search subfactories first (if any)</span>
      ptr = trySubfactories(className);
      <span class="keywordflow">if</span> (ptr) <span class="keywordflow">return</span> ptr;

      <span class="comment">// Try matching names of specific subclasses of MdIntegrator.</span>
      <span class="keywordflow">if</span> (className == <span class="stringliteral">&quot;NveVvIntegrator&quot;</span>) {
         <span class="comment">// NVE Velocity-Verlet (VV)</span>
         ptr = <span class="keyword">new</span> NVEIntegrator(*systemPtr_); 
      } <span class="keywordflow">else</span>
      <span class="keywordflow">if</span> (className == <span class="stringliteral">&quot;NvtNhIntegrator&quot;</span>) {
         <span class="comment">// NVT Nose-Hoover (NH)</span>
         ptr = <span class="keyword">new</span> NVTIntegrator(*systemPtr_);  
      } <span class="keywordflow">else</span>
      <span class="keywordflow">if</span> (className == <span class="stringliteral">&quot;NVTDpdIntegrator&quot;</span>) {
         <span class="comment">// NVT Dissipative Particle Dynamics (DPD)</span>
         ptr = <span class="keyword">new</span> NVTIntegrator(*systemPtr_); 
      }
      <span class="keywordflow">return</span> ptr;
   }

}
</pre></div><p> Note that trySubfactories() is called before the method attempts to match className to the name of several specific <a class="el" href="classMcMd_1_1MdIntegrator.html" title="Abstract base for molecular dynamics integrators.">MdIntegrator</a> subclass names. The trySubfactories() method and the factory() method each return a null pointer if it cannot find a match for the name, and return a pointer to a new object if it can.</p>
<h2><a class="anchor" id="custom_factory_extend_sec"></a>
Writing a Custom Subfactory</h2>
<p>To "teach" a factory that is derived from Factory&lt;Base&gt; to recognize new user-defined subclasses of Base by name, the developer of a new subclass must either: (1) Edit the implementation of the factory that is provided with Simpatico (e.g., edit the file <a class="el" href="MdIntegratorFactory_8cpp_source.html">MdIntegratorFactory.cpp</a>), or (2) Define a new subclass of Factory&lt;Base&gt; that recognizes the names of the new subclasses, and add this to the default Factory as a subfactory in the main program. Though method (1) is admittedly simpler, method (1) requires the user to modify files that are provided with Simpatico, which makes it hard for a user to update the code or keep it synchronized with a parent repository. We thus recommend method (2), which is described below.</p>
<p>As an example, imagine that you have written an NvtLangevinIntegrator subclass of <a class="el" href="classMcMd_1_1MdIntegrator.html" title="Abstract base for molecular dynamics integrators.">MdIntegrator</a>, because no Langevin integrator is (thus far) provided by Simpatico. You would then also define a subclass of <a class="el" href="classUtil_1_1Factory.html">Factory&lt;MdIntegrator&gt;</a>, which we will called MyMdIntegratorFactory, with a factory() method that can recognize the name "NvtLangevinIntegrator" and instantiate an object of this class. Here is an example of the required class definition: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;MdIntegratorFactory.h&quot;</span>
<span class="preprocessor">#include &quot;NvtLangevinIntegrator.h&quot;</span>

<span class="keyword">namespace </span>McMd 
{

   <span class="keyword">class </span>MyMdIntegratorFactory : <span class="keyword">public</span> Factory&lt;MdIntegrator&gt;
   {
   <span class="keyword">public</span>:

      <span class="keyword">virtual</span> MdIntegrator* factory(std::string &amp;subclassName)
      {
         MdIntegrator *ptr = 0;

         ptr = trySubfactories(className);
         <span class="keywordflow">if</span> (ptr) <span class="keywordflow">return</span> ptr;

         <span class="keywordflow">if</span> (subclassName == <span class="stringliteral">&quot;NvtLangevinIntegrator&quot;</span>) {
            ptr = <span class="keyword">new</span> NvtLangevinIntegrator(*systemPtr_);
         }
         <span class="keywordflow">return</span> ptr;
      }

   };

}
</pre></div><p> The factory method for this subclass returns a pointer to a new NvtLangevinIntegrator, if the subclassName string is "NvtLangevinIntegrator". It returns a null pointer otherwise.</p>
<h2><a class="anchor" id="set_factory_extend_sec"></a>
Adding a Custom Factory</h2>
<p>After writing a custom factory, one must invoke the addSubfactory() method of the default factory that is provided with Simpatico to register the new Factory as a subfactory of the default Factory. This must be done in the main program, before the readParam() method is invoked.</p>
<p>Below, we show an example of a main program for an <a class="el" href="classMcMd_1_1MdSimulation.html" title="A molecular dynamics simulation of a single MdSystem.">MdSimulation</a> that adds a custom factory MyMdIntegratorFactory as a subfactory to the <a class="el" href="classMcMd_1_1MdIntegratorFactory.html" title="Default Factory for subclasses of MdIntegrator.">MdIntegratorFactory</a>. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>McMd
{

   <span class="keywordtype">int</span> main 
   {
      McSimulation          sim;
      MyMdIntegratorFactory myFactory;
 
      \\ Register the custom Factory with the MdSystem
      sim.system().mdIntegratorFactory().addSubfactory(myFactory);

      \\ Read the parameter file from standard input.
      sim.readParam();
  
      \\ Read and execute the command script.
      sim.readCommands();
  
   }

}
</pre></div><p> A similar pattern is used to set user defined Factory classes for subclasses of <a class="el" href="classMcMd_1_1Species.html" title="A Species represents a set of chemically similar molecules.">Species</a>, <a class="el" href="classMcMd_1_1McMove.html" title="McMove is an abstract base class for Monte Carlo moves.">McMove</a>, and <a class="el" href="classMcMd_1_1Diagnostic.html" title="Abstract base for periodic output and/or analysis actions.">Diagnostic</a>. The <a class="el" href="classMcMd_1_1SpeciesFactory.html" title="Default Factory for subclasses of Species.">SpeciesFactory</a> and DiagnosticFactory are accessed through methods of the <a class="el" href="classMcMd_1_1Simulation.html" title="The main object in a simulation, which coordinates others.">Simulation</a> class. The <a class="el" href="classMcMd_1_1McMoveFactory.html" title="McMoveFactory for an McSimulation.">McMoveFactory</a> is accessible through a method of <a class="el" href="classMcMd_1_1McSimulation.html" title="A Monte-Carlo simulation of one McSystem.">McSimulation</a>.</p>
<h2><a class="anchor" id="custom_factory_accessor_sec"></a>
Access to Factory Classes</h2>
<p>The default Factory object for each of the polymorphic base classes in an mcSim or mdSim simulation can be accessed by reference via a method of either the <a class="el" href="classMcMd_1_1Simulation.html" title="The main object in a simulation, which coordinates others.">Simulation</a> or <a class="el" href="classMcMd_1_1System.html" title="A set of interacting Molecules enclosed by a Boundary.">McMd::System</a> classes, or of the <a class="el" href="classMcMd_1_1McSimulation.html" title="A Monte-Carlo simulation of one McSystem.">McSimulation</a>, <a class="el" href="classMcMd_1_1MdSimulation.html" title="A molecular dynamics simulation of a single MdSystem.">MdSimulation</a>, <a class="el" href="classMcMd_1_1McSystem.html" title="A System for use in a Markov chain Monte Carlo simulation.">McSystem</a> or <a class="el" href="classMcMd_1_1MdSystem.html" title="A System for Molecular Dynamics simulation.">MdSystem</a> subclasses. The required accessor methods for the factory classes used by mcSim and mdSim are: </p>
<ul>
<li>
McMd::Factory&lt;Species&gt;&amp; <a class="el" href="classMcMd_1_1Simulation.html#a8086af0046abf289da3cc1a85da97020" title="Return the Species Factory by reference.">McMd::Simulation::speciesFactory()</a>;  </li>
<li>
McMd::Factory&lt;Diagnostic&gt;&amp; <a class="el" href="classMcMd_1_1Simulation.html#ac95779326ad13ccdf35178cc4ffad987" title="Return the Diagnostic factory by reference.">McMd::Simulation::diagnosticFactory()</a>;  </li>
<li>
McMd::Factory&lt;McMove&gt;&amp; <a class="el" href="classMcMd_1_1McSimulation.html#a1e77cead3141ff5bfaa00a5fb38b06c1" title="Get the McMove factory by reference.">McMd::McSimulation::mcMoveFactory()</a>;  </li>
<li>
McMd::Factory&lt;MdIntegrator&gt;&amp; <a class="el" href="classMcMd_1_1MdSystem.html#a2464533e36432fb77fe080b3224cfa9c" title="Return the MdIntegrator Factory by reference.">McMd::MdSystem::mdIntegratorFactory()</a>;  </li>
<li>
McMd::Factory&lt;ConfigIo&gt;&amp; <a class="el" href="classMcMd_1_1System.html#a422a12fcd4c7d9da8d377afc58c3dd37" title="Get the configuration file reader/writer factory by reference.">McMd::System::configIoFactory()</a>;  </li>
<li>
McMd::Factory&lt;TrajectoryIo&gt;&amp; <a class="el" href="classMcMd_1_1System.html#a19e7cc56a740995d0b999129c2f67a8b" title="Get the trajectory reader/writer factory by reference.">McMd::MdSystem::trajectoryIoFactory()</a>;  </li>
<li>
McMd::Factory&lt;Perturbation&gt;&amp; <a class="el" href="classMcMd_1_1System.html#a4108e1167ab8a74c302cf533374f564a" title="Get the perturbation factory by reference.">McMd::System::perturbationFactory()</a>;  </li>
<li>
<a class="el" href="classMcMd_1_1PairFactory.html" title="Factory for subclasses MdPairPotential or McPairPotential.">McMd::PairFactory</a>&amp; <a class="el" href="classMcMd_1_1System.html#a7f28c02097251e76853562ab4a97c7de" title="Get the PairFactory by reference.">McMd::System::pairFactory()</a>;  </li>
<li>
McMd::Factory&lt;BondPotential&gt;&amp; <a class="el" href="classMcMd_1_1System.html#a48d6b4068d96167cd4c519e56058160d" title="Get the associated Factory&lt;BondPotential&gt; by reference.">McMd::System::bondFactory()</a>;  </li>
<li>
McMd::Factory&lt;AnglePotential&gt;&amp; McMd::System::angleFactory();  </li>
<li>
McMd::Factory&lt;DihedralPotential&gt;&amp; McMd::System::dihedralFactory();  </li>
<li>
McMd::Factory&lt;BondPotential&gt;&amp; <a class="el" href="classMcMd_1_1System.html#aa9c0fb2c5e81be12ee756bc939d01ea5" title="Get the associated Link factory by reference.">McMd::System::linkFactory()</a>;  </li>
<li>
McMd::Factory&lt;ExternalPotential&gt;&amp; <a class="el" href="classMcMd_1_1System.html#ad3beac0f5ba061c0b05fcfa208b0cf70" title="Get the associated ExternalPotential factory by reference.">McMd::System::externalFactory()</a>;  </li>
</ul>
<p>Methods of <a class="el" href="classMcMd_1_1Simulation.html" title="The main object in a simulation, which coordinates others.">Simulation</a> and <a class="el" href="classMcMd_1_1System.html" title="A set of interacting Molecules enclosed by a Boundary.">System</a> are also available in the MC and MD subclasses of these classes, and so can be used in either MC or MD simulations. See the page about <a class="el" href="potentials_page.html">Potential Energy Classes</a> for a more detailed discussion of the potential energy and potential energy factory classes.</p>
<p>When a factory must be accessed via an instance of <a class="el" href="classMcMd_1_1System.html" title="A set of interacting Molecules enclosed by a Boundary.">System</a> or one of its subclasesses, a reference to the required <a class="el" href="classMcMd_1_1McSystem.html" title="A System for use in a Markov chain Monte Carlo simulation.">McSystem</a> or <a class="el" href="classMcMd_1_1MdSystem.html" title="A System for Molecular Dynamics simulation.">MdSystem</a> object can be obtained using the system() method of the parent <a class="el" href="classMcMd_1_1McSimulation.html" title="A Monte-Carlo simulation of one McSystem.">McSimulation</a> or <a class="el" href="classMcMd_1_1MdSimulation.html" title="A molecular dynamics simulation of a single MdSystem.">MdSimulation</a> object. This is done in the above example, in which the <a class="el" href="classMcMd_1_1MdIntegratorFactory.html" title="Default Factory for subclasses of MdIntegrator.">MdIntegratorFactory</a> is accessed via the line </p>
<div class="fragment"><pre class="fragment">    simulation.system().mdIntegratorFactory().addSubfactory(myFactory);
</pre></div><p> Here, simulation is an instance of <a class="el" href="classMcMd_1_1McSimulation.html" title="A Monte-Carlo simulation of one McSystem.">McSimulation</a>. The method <a class="el" href="classMcMd_1_1McSimulation.html#a5660a84f876baadc941c26786d8b16b4" title="Get the McSystem by reference.">McSimulation::system()</a> returns a reference to the associated <a class="el" href="classMcMd_1_1McSystem.html" title="A System for use in a Markov chain Monte Carlo simulation.">McSystem</a> object. The method System::mdIntegratorFactory() then returns a reference to the default <a class="el" href="classUtil_1_1Factory.html">Factory&lt;MdIntegrator&gt;</a>. Invoking the method method Factory&lt;MdIntegrator&gt;::addSubFactory() of this factory object then adds the user-defined subfactory to the default factory.</p>
<ul>
<li>
<a class="el" href="inherit_page.html">Polymorphic Base Classes</a> (Previous)  </li>
<li>
<a class="el" href="extend_page.html">Extending Simpatico</a> (Up)  </li>
<li>
<a class="el" href="potentials_page.html">Potential Energy Classes</a> (Next)  </li>
</ul>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Aug 26 2012 06:54:21 for Simpatico by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
